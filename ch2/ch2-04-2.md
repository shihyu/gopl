### 2.4.2. 可賦值性

賦值語句是顯式的賦值形式，但是程序中還有很多地方會發生隱式的賦值行為：函數調用會隱式地將調用參數的值賦值給函數的參數變量，一個返回語句會隱式地將返回操作的值賦值給結果變量，一個複合類型的字面量（§4.2）也會產生賦值行為。例如下面的語句：

```Go
medals := []string{"gold", "silver", "bronze"}
```

隱式地對slice的每個元素進行賦值操作，類似這樣寫的行為：

```Go
medals[0] = "gold"
medals[1] = "silver"
medals[2] = "bronze"
```

map和chan的元素，雖然不是普通的變量，但是也有類似的隱式賦值行為。

不管是隱式還是顯式地賦值，在賦值語句左邊的變量和右邊最終的求到的值必須有相同的數據類型。更直白地說，只有右邊的值對於左邊的變量是可賦值的，賦值語句才是允許的。

可賦值性的規則對於不同類型有著不同要求，對每個新類型特殊的地方我們會專門解釋。對於目前我們已經討論過的類型，它的規則是簡單的：類型必須完全匹配，nil可以賦值給任何指針或引用類型的變量。常量（§3.6）則有更靈活的賦值規則，因為這樣可以避免不必要的顯式的類型轉換。

對於兩個值是否可以用`==`或`!=`進行相等比較的能力也和可賦值能力有關係：對於任何類型的值的相等比較，第二個值必須是對第一個值類型對應的變量是可賦值的，反之亦然。和前面一樣，我們會對每個新類型比較特殊的地方做專門的解釋。
