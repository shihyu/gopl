### 11.2.5. 編寫有效的測試

許多Go語言新人會驚異於Go語言極簡的測試框架。很多其它語言的測試框架都提供了識別測試函數的機制（通常使用反射或元數據），通過設置一些“setup”和“teardown”的鉤子函數來執行測試用例運行的初始化和之後的清理操作，同時測試工具箱還提供了很多類似assert斷言、值比較函數、格式化輸出錯誤信息和停止一個失敗的測試等輔助函數（通常使用異常機制）。雖然這些機制可以使得測試非常簡潔，但是測試輸出的日誌卻會像火星文一般難以理解。此外，雖然測試最終也會輸出PASS或FAIL的報告，但是它們提供的信息格式卻非常不利於代碼維護者快速定位問題，因為失敗信息的具體含義非常隱晦，比如“assert: 0 == 1”或成頁的海量跟蹤日誌。

Go語言的測試風格則形成鮮明對比。它期望測試者自己完成大部分的工作，定義函數避免重複，就像普通編程那樣。編寫測試並不是一個機械的填空過程；一個測試也有自己的接口，儘管它的維護者也是測試僅有的一個用戶。一個好的測試不應該引發其他無關的錯誤信息，它只要清晰簡潔地描述問題的症狀即可，有時候可能還需要一些上下文信息。在理想情況下，維護者可以在不看代碼的情況下就能根據錯誤信息定位錯誤產生的原因。一個好的測試不應該在遇到一點小錯誤時就立刻退出測試，它應該嘗試報告更多的相關的錯誤信息，因為我們可能從多個失敗測試的模式中發現錯誤產生的規律。

下面的斷言函數比較兩個值，然後生成一個通用的錯誤信息，並停止程序。它很好用也確實有效，但是當測試失敗的時候，打印的錯誤信息卻幾乎是沒有價值的。它並沒有為快速解決問題提供一個很好的入口。

```Go
import (
	"fmt"
	"strings"
	"testing"
)
// A poor assertion function.
func assertEqual(x, y int) {
	if x != y {
		panic(fmt.Sprintf("%d != %d", x, y))
	}
}
func TestSplit(t *testing.T) {
	words := strings.Split("a:b:c", ":")
	assertEqual(len(words), 3)
	// ...
}
```

從這個意義上說，斷言函數犯了過早抽象的錯誤：僅僅測試兩個整數是否相同，而沒能根據上下文提供更有意義的錯誤信息。我們可以根據具體的錯誤打印一個更有價值的錯誤信息，就像下面例子那樣。只有在測試中出現重複模式時才採用抽象。

```Go
func TestSplit(t *testing.T) {
	s, sep := "a:b:c", ":"
	words := strings.Split(s, sep)
	if got, want := len(words), 3; got != want {
		t.Errorf("Split(%q, %q) returned %d words, want %d",
			s, sep, got, want)
	}
	// ...
}
```

現在的測試不僅報告了調用的具體函數、它的輸入和結果的意義；並且打印的真實返回的值和期望返回的值；並且即使斷言失敗依然會繼續嘗試運行更多的測試。一旦我們寫了這樣結構的測試，下一步自然不是用更多的if語句來擴展測試用例，我們可以用像IsPalindrome的表驅動測試那樣來準備更多的s和sep測試用例。

前面的例子並不需要額外的輔助函數，如果有可以使測試代碼更簡單的方法我們也樂意接受。（我們將在13.3節看到一個類似reflect.DeepEqual輔助函數。）一個好的測試的關鍵是首先實現你期望的具體行為，然後才是考慮簡化測試代碼、避免重複。如果直接從抽象、通用的測試庫著手，很難取得良好結果。

**練習11.5:** 用表格驅動的技術擴展TestSplit測試，並打印期望的輸出結果。


