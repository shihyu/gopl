### 9.8.4. Goroutine沒有ID號

在大多數支持多線程的操作系統和程序語言中，當前的線程都有一個獨特的身份（id），並且這個身份信息可以以一個普通值的形式被很容易地獲取到，典型的可以是一個integer或者指針值。這種情況下我們做一個抽象化的thread-local storage（線程本地存儲，多線程編程中不希望其它線程訪問的內容）就很容易，只需要以線程的id作為key的一個map就可以解決問題，每一個線程以其id就能從中獲取到值，且和其它線程互不衝突。

goroutine沒有可以被程序員獲取到的身份（id）的概念。這一點是設計上故意而為之，由於thread-local storage總是會被濫用。比如說，一個web server是用一種支持tls的語言實現的，而非常普遍的是很多函數會去尋找HTTP請求的信息，這代表它們就是去其存儲層（這個存儲層有可能是tls）查找的。這就像是那些過分依賴全局變量的程序一樣，會導致一種非健康的“距離外行為”，在這種行為下，一個函數的行為可能並不僅由自己的參數所決定，而是由其所運行在的線程所決定。因此，如果線程本身的身份會改變——比如一些worker線程之類的——那麼函數的行為就會變得神祕莫測。

Go鼓勵更為簡單的模式，這種模式下參數（譯註：外部顯式參數和內部顯式參數。tls 中的內容算是"外部"隱式參數）對函數的影響都是顯式的。這樣不僅使程序變得更易讀，而且會讓我們自由地向一些給定的函數分配子任務時不用擔心其身份信息影響行為。

你現在應該已經明白了寫一個Go程序所需要的所有語言特性信息。在後面兩章節中，我們會回顧一些之前的實例和工具，支持我們寫出更大規模的程序：如何將一個工程組織成一系列的包，如何獲取，構建，測試，性能測試，剖析，寫文檔，並且將這些包分享出去。

