### 9.8.2. Goroutine調度

OS線程會被操作系統內核調度。每幾毫秒，一個硬件計時器會中斷處理器，這會調用一個叫作scheduler的內核函數。這個函數會掛起當前執行的線程並將它的寄存器內容保存到內存中，檢查線程列表並決定下一次哪個線程可以被運行，並從內存中恢復該線程的寄存器信息，然後恢復執行該線程的現場並開始執行線程。因為操作系統線程是被內核所調度，所以從一個線程向另一個“移動”需要完整的上下文切換，也就是說，保存一個用戶線程的狀態到內存，恢復另一個線程的到寄存器，然後更新調度器的數據結構。這幾步操作很慢，因為其局部性很差需要幾次內存訪問，並且會增加運行的cpu週期。

Go的運行時包含了其自己的調度器，這個調度器使用了一些技術手段，比如m:n調度，因為其會在n個操作系統線程上多工（調度）m個goroutine。Go調度器的工作和內核的調度是相似的，但是這個調度器只關注單獨的Go程序中的goroutine（譯註：按程序獨立）。

和操作系統的線程調度不同的是，Go調度器並不是用一個硬件定時器，而是被Go語言“建築”本身進行調度的。例如當一個goroutine調用了time.Sleep，或者被channel調用或者mutex操作阻塞時，調度器會使其進入休眠並開始執行另一個goroutine，直到時機到了再去喚醒第一個goroutine。因為這種調度方式不需要進入內核的上下文，所以重新調度一個goroutine比調度一個線程代價要低得多。

** 練習 9.5: ** 寫一個有兩個goroutine的程序，兩個goroutine會向兩個無buffer channel反覆地發送ping-pong消息。這樣的程序每秒可以支持多少次通信？
